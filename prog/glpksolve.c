/* glpksolve.c -  LP solver for witip */

/***********************************************************************
 * This code is part of WITIP, (a Web/based  Information Theoretic Prover)
 *
 * Copyright 2017-2024 Laszlo Csirmaz, UTIA, Prague
 *
 * This program is free, open-source software. You may redistribute it
 * and/or modify under the terms of the GNU General Public License (GPL).
 *
 * There is ABSOLUTELY NO WARRANTY, use at your own risk.
 ************************************************************************/

/* Solving an LP instance generated by Makelp.pm
   Arguments: <input-file> <output-file>
   The <output-file> contains two lines. The first line is a single digit:
      EXPR_TRUE    - the relation (==0 or >=0) holds
      EXPR_FALSE   - the relation does not hold
      EQ_LE_ONLY   - only <=0 holds (when checking for ==0)
      EQ_GE_ONLY   - only >=0 holds (when checking for ==0)
      EXPR_ERROR   - the LP solver failed
      EXPR_TIMEOUT - timeout
   The second line is either empty, or a verbose reason for the LP failure
   (e.g., timeout, numerical instability, etc.)
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "glpk.h"

/*========================================================================*/

/* result codes of the LP checker */
#define EXPR_TRUE	0    // the relation checks OK
#define EXPR_FALSE	1    // the relation does not hold
#define EQ_LE_ONLY	2    // >=0 holds only when checking ==0
#define EQ_GE_ONLY	3    // <=0 holds only when checking ==0
#define EXPR_ERROR	4    // LP failed
#define EXPR_TIMEOUT	5    // LP had a timeout

/* exit values for the main program */
#define INPUT_ERROR	11   // error in input file
#define EXIT_OK		0    // LP has been started

/*========================================================================*/
/* glpk interface */

static glp_prob *P=NULL;      /* glpk structure */
static glp_smcp parm;         /* glpk parameters */

static void create_glp(int cols, int rows)
{int i;
    glp_term_out(GLP_OFF);    // no output from glpk
    P=glp_create_prob();      // create problem
    glp_add_cols(P,cols);     // specify the size of the problem
    glp_add_rows(P,rows);
    /* set the objective to all zero */
    for(i=0;i<=cols;i++) glp_set_obj_coef(P,i,0.0);
    glp_set_obj_dir(P,GLP_MIN); // minimize
}
/* clean up all results */
static void release_glp(void){
    if(P){ glp_delete_prob(P); P=NULL; }
}
/* init glp parameters */
static void init_glp_parameters(int timelimit){
    glp_init_smcp(&parm);
    parm.meth = GLP_DUAL;        // PRIMAL,DUAL,DUALP
    parm.msg_lev = GLP_MSG_OFF;  // OFF,ON,ALL,ERR
    parm.pricing = GLP_PT_PSE;   // PSE, STD
    parm.r_test = GLP_RT_HAR;    // HAR,STD
    parm.it_lim = 10000000;      // no limit on iteration
    parm.tm_lim = 1000*timelimit;// in microseconds
    parm.presolve = GLP_ON;      // presolve, helps on numerical stability
}
/* glp error messages */
static char glp_msg[60]={0};
static void glp_status_msg(int stat)
{static char *statmsg[]={
"solution is undefined",        // GLP_UNDEF
"solution is feasible",         // GLP_FEAS
"solution is unfeasible",       // GLP_INFEAS
"no feasible solution exists",  // GLP_NOFEAS
"solution is optimal",          // GLP_OPT
"solution is unbounded",        // GLP_UNBND
};
    if(1<=stat && stat<=(int)((sizeof(statmsg)/sizeof(char*))) ){
        strncpy(glp_msg,statmsg[stat-1],60);
        return;
    }
    sprintf(glp_msg,"unknown LP status %d",stat);
}
static void glp_return_msg(int retval)
{
static char *retmsg[] = {
"invalid basis",                        // GLP_EBADB     *
"singular matrix",                      // GLP_ESING     *
"ill-conditioned matrix",               // GLP_ECOND     *
"invalid bounds",                       // GLP_EBOUND
"solver failed",                        // GLP_EFAIL     *
"objective lower limit reached",        // GLP_EOBJLL
"objective upper limit reached",        // GLP_EOBJUL
"iteration limit exceeded",             // GLP_EITLIM    *
"time limit exceeded",                  // GLP_ETMLIM    *
"no primal feasible solution",          // GLP_ENOPFS    *
"no dual feasible solution",            // GLP_ENODFS
"root LP optimum not provided",         // GLP_EROOT
"search terminated by application",     // GLP_ESTOP
"relative mip gap tolerance reached",   // GLP_EMIPGAP
"no primal/dual feasible solution",     // GLP_ENOFEAS
"no convergence",                       // GLP_ENOCVG
"numerical instability",                // GLP_EINSTAB
"invalid data",                         // GLP_EDATA
"result out of range",                  // GLP_ERANGE
};
    if(1<=retval && retval <=(int)((sizeof(retmsg)/sizeof(char*)))){
        strncpy(glp_msg,retmsg[retval-1],60);
        return;
    }
    sprintf(glp_msg,"unknown LP return code %d",retval);
}
/*========================================================================*/
/* global variables */
int cols, rows;                  // number of problem columns and rows
int timeout;                     // timeout in seconds
int target;                      // 0 for >=0; 1 for ==0
int *row_idx=NULL;               // storing a column (row indices and values)
double *row_val=NULL;
int tmpsize=0;                   // size of the above arrays
int entries;                     // number of entries in the above arrays

/* allocate arrays to hold the next column data */
static void allocate_tmprow(int cnt)
{   cnt=(cnt+1024)&~1023; // make it a multiple of 1024
    if(cnt <= tmpsize) return;
    tmpsize=cnt;
    row_idx=realloc(row_idx,cnt*sizeof(int));
    row_val=realloc(row_val,cnt*sizeof(double));
    if(!row_idx || !row_val){
       fprintf(stderr,"glpksolve: out of memory...\n");
       exit(INPUT_ERROR);
    }
}
static void read_input(char *fname)
{int i,j, type;
FILE *file;
    file=fopen(fname,"r");
    if(!file){ // input error
        fprintf(stderr,"Cannot open input file %s\n",fname);
        exit(INPUT_ERROR);
    }
    if(4!=fscanf(file,"P%d%d%d%d",&timeout,&target,&cols,&rows) ||
       timeout < 1 || (target!=0 && target!=1) || cols<2 || cols>250000 ||
       rows<2 || rows>250000 ){ 
        fprintf(stderr,"glpksolve: wrong P input line in %s\n",fname);
        exit(INPUT_ERROR); // input error
    }
    create_glp(cols,rows);
    // for each column read that column
    for(i=1;i<=cols+1;i++){
        if(2!=fscanf(file,"\nC%d%d",&type,&entries) || 
            (i==cols+1 && type!=2) || (i<=cols && type!=0 && type!=1) || 
            entries<1 || entries>rows){
             fprintf(stderr,"glpksolve: wrong C input line, col=%d\n",i);
             exit(INPUT_ERROR);
        }
        allocate_tmprow(entries); // row_idx,row_val
        for(j=1;j<=entries;j++){
            if(2!=fscanf(file,"\nN%d%lg",row_idx+j,row_val+j) ||
               row_idx[j]<1 || row_idx[j]>rows){
               fprintf(stderr,"glpksolve: wrong N input line, i=%d, j=%d, cols=%d, entries=%d\n",i,j,cols,entries);
               exit(INPUT_ERROR);
            }
        }
        if(i<=cols){ // add column i to the problem
           glp_set_col_bnds(P,i,(type?GLP_FR : GLP_LO),0.0,0.0);
           glp_set_mat_col(P,i,entries,row_idx,row_val);
        }
    }
    fclose(file);
}
static void add_goal(int negate)
{int i,in; double v;
    for(i=1,in=1;i<=rows;i++){
        if(in<=entries && row_idx[in]==i) {v=row_val[in]; in++; }
        else { v=0.0; }
        if(negate){ v=-v; }
        glp_set_row_bnds(P,i,GLP_FX,v,v);
    }
}
/* run the lp solver and interpret its output */
static int invoke_lp(void)
{int glp_res;
    glp_res=glp_simplex(P,&parm);
    switch(glp_res){
  case 0:           glp_res=glp_get_status(P); break;
  case GLP_ENOPFS:  return EXPR_FALSE;   // no feasible solution
  case GLP_ETMLIM:  return EXPR_TIMEOUT; // timeout
  default:          glp_return_msg(glp_res); return EXPR_ERROR;
    }
    if(glp_res==GLP_OPT) return EXPR_TRUE; // feasible solution
    if(glp_res==GLP_NOFEAS) return EXPR_FALSE;
    glp_status_msg(glp_res);
    return EXPR_ERROR;
}
/* input is read, goal is in (row_idx,row_val), target is 0/1
   glpk problem instance P is initialized */
static int call_lp(void)
{int retval, retval2;
    add_goal(0); // add original goal
    init_glp_parameters(timeout);
    if(target){
        parm.presolve=GLP_OFF;
        glp_scale_prob(P,GLP_SF_AUTO);
        glp_adv_basis(P,0);
    }
    retval = invoke_lp();
    if(target && (retval==EXPR_TRUE || retval==EXPR_FALSE)){ // check ==0
        add_goal(-1);
        retval2=invoke_lp();
        if(retval2==EXPR_TRUE){
            if(retval==EXPR_FALSE) retval=EQ_LE_ONLY;
        } else if(retval2==EXPR_FALSE){
            if(retval==EXPR_TRUE) retval=EQ_GE_ONLY;
        } else {
            retval=retval2;
        }
    }
    release_glp(); // release allocated memory
    return retval;
}
/*========================================================================*/
/* run the LP in the background; don't wait until it finishes */
#include <unistd.h>
static int detach(void) // return 1 for the child, 0 for the parent
{pid_t pid=0;
    close(STDIN_FILENO); dup2(STDERR_FILENO,STDOUT_FILENO);
    pid=fork();         // fork the parent process
    if(pid<0) return 1; // some error
    if(pid>0) return 0; // parent
    setsid();
    return 1;           // child
}

/*========================================================================*/
/* main routine 
 Possible returned values are:
    INPUT_ERROR - indicating that the there was an error reading the problem
    0 (zero)    - indicating that we went to the background and the LP
                  solver started to work. The background process always 
                  returns with code zero even if there were errors.
*/

int main(int argc, char *argv[])
{int ret; FILE *out;
    if(argc!=3){
        fprintf(stderr,
"glpksolve - this is a utility program to WITIP, a web-based inequality prover\n"
"usage: glpksolve <input> <output>\n");
        return INPUT_ERROR;
    }
    read_input(argv[1]);
    if(detach()){ // child process
        ret=call_lp();
        out=fopen(argv[2],"w");
        if(out){
            fprintf(out,"%d\n%s\n",ret,glp_msg);
            fclose(out);
        } else fprintf(stderr,"Cannot create ouput file %s\n",argv[2]);
    } else {
        usleep(100000); // wait 100 ms
    }
    return 0;
}

/* EOF */

